{"ast":null,"code":"/*\nHTML escaping is the same as React's\n(on purpose.) Therefore, it has the following Copyright and Licensing:\n\nCopyright 2013-2014, Facebook, Inc.\nAll rights reserved.\n\nThis source code is licensed under the BSD-style license found in the LICENSE\nfile in the root directory of React's source tree.\n*/\nimport * as React from 'react';\nimport IntlMessageFormat from 'intl-messageformat';\nimport memoizeIntlConstructor from 'intl-format-cache';\nimport { invariant } from '@formatjs/intl-utils';\nimport { UnsupportedFormatterError } from './error';\nexport function filterProps(props, whitelist, defaults) {\n  if (defaults === void 0) {\n    defaults = {};\n  }\n\n  return whitelist.reduce(function (filtered, name) {\n    if (name in props) {\n      filtered[name] = props[name];\n    } else if (name in defaults) {\n      filtered[name] = defaults[name];\n    }\n\n    return filtered;\n  }, {});\n}\nexport function invariantIntlContext(intl) {\n  invariant(intl, '[React Intl] Could not find required `intl` object. ' + '<IntlProvider> needs to exist in the component ancestry.');\n}\nexport var defaultErrorHandler = function (error) {\n  if (process.env.NODE_ENV !== 'production') {\n    console.error(error);\n  }\n};\nexport var DEFAULT_INTL_CONFIG = {\n  formats: {},\n  messages: {},\n  timeZone: undefined,\n  textComponent: React.Fragment,\n  defaultLocale: 'en',\n  defaultFormats: {},\n  onError: defaultErrorHandler\n};\nexport function createIntlCache() {\n  return {\n    dateTime: {},\n    number: {},\n    message: {},\n    relativeTime: {},\n    pluralRules: {},\n    list: {},\n    displayNames: {}\n  };\n}\n/**\n * Create intl formatters and populate cache\n * @param cache explicit cache to prevent leaking memory\n */\n\nexport function createFormatters(cache) {\n  if (cache === void 0) {\n    cache = createIntlCache();\n  }\n\n  var RelativeTimeFormat = Intl.RelativeTimeFormat;\n  var ListFormat = Intl.ListFormat;\n  var DisplayNames = Intl.DisplayNames;\n  return {\n    getDateTimeFormat: memoizeIntlConstructor(Intl.DateTimeFormat, cache.dateTime),\n    getNumberFormat: memoizeIntlConstructor(Intl.NumberFormat, cache.number),\n    getMessageFormat: memoizeIntlConstructor(IntlMessageFormat, cache.message),\n    getRelativeTimeFormat: memoizeIntlConstructor(RelativeTimeFormat, cache.relativeTime),\n    getPluralRules: memoizeIntlConstructor(Intl.PluralRules, cache.pluralRules),\n    getListFormat: memoizeIntlConstructor(ListFormat, cache.list),\n    getDisplayNames: memoizeIntlConstructor(DisplayNames, cache.displayNames)\n  };\n}\nexport function getNamedFormat(formats, type, name, onError) {\n  var formatType = formats && formats[type];\n  var format;\n\n  if (formatType) {\n    format = formatType[name];\n  }\n\n  if (format) {\n    return format;\n  }\n\n  onError(new UnsupportedFormatterError(\"No \" + type + \" format named: \" + name));\n}\n/**\n * Takes a `formatXMLElementFn`, and composes it in function, which passes\n * argument `parts` through, assigning unique key to each part, to prevent\n * \"Each child in a list should have a unique \"key\"\" React error.\n * @param formatXMLElementFn\n */\n\nexport function assignUniqueKeysToParts(formatXMLElementFn) {\n  return function (parts) {\n    // eslint-disable-next-line prefer-rest-params\n    return formatXMLElementFn(React.Children.toArray(parts));\n  };\n}","map":{"version":3,"sources":["D:/MyDesktop/lab8/node_modules/react-intl/lib/src/utils.js"],"names":["React","IntlMessageFormat","memoizeIntlConstructor","invariant","UnsupportedFormatterError","filterProps","props","whitelist","defaults","reduce","filtered","name","invariantIntlContext","intl","defaultErrorHandler","error","process","env","NODE_ENV","console","DEFAULT_INTL_CONFIG","formats","messages","timeZone","undefined","textComponent","Fragment","defaultLocale","defaultFormats","onError","createIntlCache","dateTime","number","message","relativeTime","pluralRules","list","displayNames","createFormatters","cache","RelativeTimeFormat","Intl","ListFormat","DisplayNames","getDateTimeFormat","DateTimeFormat","getNumberFormat","NumberFormat","getMessageFormat","getRelativeTimeFormat","getPluralRules","PluralRules","getListFormat","getDisplayNames","getNamedFormat","type","formatType","format","assignUniqueKeysToParts","formatXMLElementFn","parts","Children","toArray"],"mappings":"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","sourcesContent":["/*\nHTML escaping is the same as React's\n(on purpose.) Therefore, it has the following Copyright and Licensing:\n\nCopyright 2013-2014, Facebook, Inc.\nAll rights reserved.\n\nThis source code is licensed under the BSD-style license found in the LICENSE\nfile in the root directory of React's source tree.\n*/\nimport * as React from 'react';\nimport IntlMessageFormat from 'intl-messageformat';\nimport memoizeIntlConstructor from 'intl-format-cache';\nimport { invariant } from '@formatjs/intl-utils';\nimport { UnsupportedFormatterError } from './error';\nexport function filterProps(props, whitelist, defaults) {\n    if (defaults === void 0) { defaults = {}; }\n    return whitelist.reduce(function (filtered, name) {\n        if (name in props) {\n            filtered[name] = props[name];\n        }\n        else if (name in defaults) {\n            filtered[name] = defaults[name];\n        }\n        return filtered;\n    }, {});\n}\nexport function invariantIntlContext(intl) {\n    invariant(intl, '[React Intl] Could not find required `intl` object. ' +\n        '<IntlProvider> needs to exist in the component ancestry.');\n}\nexport var defaultErrorHandler = function (error) {\n    if (process.env.NODE_ENV !== 'production') {\n        console.error(error);\n    }\n};\nexport var DEFAULT_INTL_CONFIG = {\n    formats: {},\n    messages: {},\n    timeZone: undefined,\n    textComponent: React.Fragment,\n    defaultLocale: 'en',\n    defaultFormats: {},\n    onError: defaultErrorHandler,\n};\nexport function createIntlCache() {\n    return {\n        dateTime: {},\n        number: {},\n        message: {},\n        relativeTime: {},\n        pluralRules: {},\n        list: {},\n        displayNames: {},\n    };\n}\n/**\n * Create intl formatters and populate cache\n * @param cache explicit cache to prevent leaking memory\n */\nexport function createFormatters(cache) {\n    if (cache === void 0) { cache = createIntlCache(); }\n    var RelativeTimeFormat = Intl.RelativeTimeFormat;\n    var ListFormat = Intl.ListFormat;\n    var DisplayNames = Intl.DisplayNames;\n    return {\n        getDateTimeFormat: memoizeIntlConstructor(Intl.DateTimeFormat, cache.dateTime),\n        getNumberFormat: memoizeIntlConstructor(Intl.NumberFormat, cache.number),\n        getMessageFormat: memoizeIntlConstructor(IntlMessageFormat, cache.message),\n        getRelativeTimeFormat: memoizeIntlConstructor(RelativeTimeFormat, cache.relativeTime),\n        getPluralRules: memoizeIntlConstructor(Intl.PluralRules, cache.pluralRules),\n        getListFormat: memoizeIntlConstructor(ListFormat, cache.list),\n        getDisplayNames: memoizeIntlConstructor(DisplayNames, cache.displayNames),\n    };\n}\nexport function getNamedFormat(formats, type, name, onError) {\n    var formatType = formats && formats[type];\n    var format;\n    if (formatType) {\n        format = formatType[name];\n    }\n    if (format) {\n        return format;\n    }\n    onError(new UnsupportedFormatterError(\"No \" + type + \" format named: \" + name));\n}\n/**\n * Takes a `formatXMLElementFn`, and composes it in function, which passes\n * argument `parts` through, assigning unique key to each part, to prevent\n * \"Each child in a list should have a unique \"key\"\" React error.\n * @param formatXMLElementFn\n */\nexport function assignUniqueKeysToParts(formatXMLElementFn) {\n    return function (parts) {\n        // eslint-disable-next-line prefer-rest-params\n        return formatXMLElementFn(React.Children.toArray(parts));\n    };\n}\n"]},"metadata":{},"sourceType":"module"}